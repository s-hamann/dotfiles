# vim: foldmethod=marker
# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
    # Shell is non-interactive.  Be done now!
    return
fi

autoload -Uz add-zsh-hook

# Key Bindings {{{

# use vi-style key bindings
bindkey -v

# create a zkbd compatible hash, but do not use zkbd itself
# to add other keys to this hash, see: man 5 terminfo
typeset -A key

key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}
if [[ -n ${terminfo[kent]} ]]; then
	key[KeypadEnter]=${terminfo[kent]} # does not work in screen and tmux
else
	key[KeypadEnter]="\eOM" # this is what xterm uses...
fi
key[ShiftTab]=${terminfo[kcbt]}

# bind keys to functions
[[ -n "${key[Home]}"    ]]  && bindkey  "${key[Home]}"    beginning-of-line
[[ -n "${key[End]}"     ]]  && bindkey  "${key[End]}"     end-of-line
[[ -n "${key[Insert]}"  ]]  && bindkey  "${key[Insert]}"  overwrite-mode
[[ -n "${key[Delete]}"  ]]  && bindkey  "${key[Delete]}"  delete-char
[[ -n "${key[Up]}"      ]]  && bindkey  "${key[Up]}"      up-line-or-history
[[ -n "${key[Down]}"    ]]  && bindkey  "${key[Down]}"    down-line-or-history
[[ -n "${key[Left]}"    ]]  && bindkey  "${key[Left]}"    backward-char
[[ -n "${key[Right]}"   ]]  && bindkey  "${key[Right]}"   forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"    history-beginning-search-backward
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}"  history-beginning-search-forward
[[ -n "${key[KeypadEnter]}"   ]]  && bindkey  "${key[KeypadEnter]}"   accept-line
[[ -n "${key[ShiftTab]}"   ]]  && bindkey  "${key[ShiftTab]}"   reverse-menu-complete

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
	#function zle-line-init () {
	function terminfo_zle-line-init () {
		echoti smkx
	}
	#function zle-line-finish () {
	function terminfo_zle-line-finish () {
		echoti rmkx
	}
	#zle -N zle-line-init
	#zle -N zle-line-finish
	# Note: these are called later by the real zle-line-init and zle-line-finish widgets
fi

# Ctrl+arrow keys, these do not seem to have a terminfo entry
bindkey -M viins "\e[1;5D" backward-word
bindkey -M viins "\e[1;5C" forward-word
bindkey -M vicmd "\e[1;5D" backward-word
bindkey -M vicmd "\e[1;5C" forward-word

# make backward-word, forward-word and ^W not stop at the following characters
# default: WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>'
export WORDCHARS=${WORDCHARS:s@/@} # remove /

# reduce lag when changing line editing modes
export KEYTIMEOUT=1
# fix some keys that do not work after returning from command mode
bindkey '^?' backward-delete-char
bindkey '^H' backward-delete-char
bindkey '^W' backward-kill-word
bindkey '^U' backward-kill-line
bindkey '^K' kill-line

insert-last-typed-word() { zle insert-last-word -- 0 -1 };
zle -N insert-last-typed-word;

# use Ctrl+R for backward search in history
bindkey '^R' history-incremental-pattern-search-backward
# make . work in history search
bindkey -M isearch '.' self-insert
# use Ctrl+Y to insert the last string deleted by ^U or whatever
bindkey -M viins '^Y' yank
# use Alt+. to insert the last parameter from the previous command
bindkey -M viins '^[.' insert-last-word
# use Ctrl+Z to insert the last parameter from the current command
bindkey -M viins '^Z' insert-last-typed-word
# use ga in vicmd mode to get information about the character under the cursor
bindkey -M vicmd ga what-cursor-position
# make # in vicmd toggle comment, but not accept the line
bindkey -M vicmd '#' vi-pound-insert
# make ESC exit mini-buffers
bindkey -M command '^[' send-break
bindkey -M isearch '^[' send-break
# use Y to yank to the end of a line, instead of the whole line
bindkey -M vicmd 'Y' vi-yank-eol
# use K in vicmd to open the man-page
bindkey -M vicmd 'K' run-help
# make H/L go to the start/end of the line in vicmd
bindkey -M vicmd 'H' beginning-of-line
bindkey -M vicmd 'L' end-of-line

# enable the powerful command line editor
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey -M vicmd 'v' edit-command-line

# This was written entirely by Mikael Magnusson
# Basically type '...' to get '../..' with successive .'s adding /..
function rationalise-dot {
	# keep variables that are generated by =~ local
	local MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
	if [[ $LBUFFER =~ '(^|/| | |'$'\n''|\||;|&)\.\.$' ]]; then
		LBUFFER+=/
		zle self-insert
		zle self-insert
	else
		zle self-insert
	fi
}
zle -N rationalise-dot
# Note: do not bind this in other modes!
bindkey -M viins . rationalise-dot

prepend-sudo() {
    # keep variables that are generated by =~ local
    local MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
    # prepend sudo if the line does not start with sudo already
    if [[ ! $LBUFFER =~ '^\s*sudo ' ]]; then
        LBUFFER="sudo $LBUFFER"
    fi
}
# Note: The widget is named differently from the function because otherwise
# zsh-syntax-highlighting would not update afterwards.
zle -N zle-prepend-sudo prepend-sudo
bindkey -M viins "^[s" zle-prepend-sudo
bindkey -M vicmd "^[s" zle-prepend-sudo

# }}}

# Colour settings {{{

# Set $TERM to support colours
if [[ -n "${COLORTERM}" || -n "${VTE_VERSION}" ]]; then
	case "$TERM" in
		'xterm') TERM='xterm-256color' ;;
		'screen') TERM='screen-256color' ;;
	esac
	export TERM
fi

# set LS_COLORS, which is used by ls and some others to colourise file names
if type dircolors > /dev/null ; then
	if [[ -f "~/.dir_colors.$TERM" ]]; then
		eval $(dircolors -b "~/.dir_colors.$TERM")
	elif [[ -f "/etc/DIR_COLORS.$TERM" ]] ; then
		eval $(dircolors -b "/etc/DIR_COLORS.$TERM")
	elif [[ -f "~/.dir_colors" ]]; then
		eval $(dircolors -b "~/.dir_colors")
	elif [[ -f "/etc/DIR_COLORS" ]] ; then
		eval $(dircolors -b "/etc/DIR_COLORS")
	fi
fi

# support colours in less
export LESS_TERMCAP_mb=$'\E[01;31m' # begin blink
export LESS_TERMCAP_md=$'\E[01;34m' # begin bold
export LESS_TERMCAP_me=$'\E[0m' # end mode
export LESS_TERMCAP_so=$'\E[01;33m' # begin stand-out mode
export LESS_TERMCAP_se=$'\E[0m' # end stand-out mode
export LESS_TERMCAP_us=$'\E[04;32m' # begin underline
export LESS_TERMCAP_ue=$'\E[0m' # end underline

# coloured GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# nice colours in grep
export GREP_COLORS='sl=38;5;230:ms=1;4;38;5;221:mc=4;38;5;221:fn=38;5;165:ln=38;5;46:se=38;5;241'

# }}}

# History settings {{{
HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=5000
setopt appendhistory # append to existing history rather than writing a new one
setopt hist_ignore_dups # ignore consecutive duplicates
setopt hist_ignore_space # ignore commands with a leading space
setopt hist_reduce_blanks # remove superfluous blanks from history
setopt hist_find_no_dups # ignore all duplicates when searching the history
setopt no_bang_hist # disable access to the history with !

# the following function allows to exclude boring commands from the history
zshaddhistory_ignore() {
	# $1 is the command line
	# return value means
	# 0 - add to history
	# 1 - do not add to history
	# 2 - add to history but do not store in history file
	# uses $HISTIGNORE, which should be an array of regexes

	# keep variables that are generated by =~ local
	local MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
	# check if this is configured at all
	[[ -z "${HISTIGNORE}" ]] && return 0
	# try each regex in $HISTIGNORE until the first match
	for regex in ${HISTIGNORE}; do
		[[ "${1%%$'\n'}" =~ "$regex" ]] && return 2
	done
	# nothing matched
	return 0
}
add-zsh-hook zshaddhistory zshaddhistory_ignore

HISTIGNORE=()
# no command with only one or two characters is important enough for the history
HISTIGNORE+=('^..?$')
HISTIGNORE+=('^l(s|l) $')
HISTIGNORE+=('^pwd$')
HISTIGNORE+=('^git (status|graph)$')
#HISTIGNORE+=('^(exit|logout)$')
#HISTIGNORE+=('^clear$')

# }}}

# Directory navigation {{{
setopt auto_cd
setopt auto_pushd
setopt pushd_ignore_dups
# }}}

# Various settings {{{

# allow comments in the interactive shell
setopt interactive_comments

# make > not overwrite files (use >! or >| instead)
# also, >> does not create new files (again, >>! or >>|)
setopt no_clobber

# }}}

# Crazy Prompt Settings {{{

# enable colours
autoload -Uz colors
colors

# set up vcs_info {{{
autoload -Uz vcs_info

# Default to running vcs_info. If possible we prevent running it later for
# speed reasons. If set to a non empty value vcs_info is run.
FORCE_RUN_VCS_INFO=1

zmodload zsh/datetime

precmd_vcs_info() {
	# Run vcs_info and measure how long it takes.
	local vcs_info_start vcs_info_finish
	vcs_info_start=$EPOCHREALTIME
	vcs_info
	vcs_info_finish=$EPOCHREALTIME
	# Update vcs_info_time with the measured time if this run was not
	# aborted early by pre-get-data.
	${vcs_info_timing} && vcs_info_time=$(( $vcs_info_finish - $vcs_info_start ))
	unset vcs_info_timing
}
add-zsh-hook precmd precmd_vcs_info

# Must run vcs_info when changing directories.
chpwd_vcs_info() {
	FORCE_RUN_VCS_INFO=1
}
add-zsh-hook chpwd chpwd_vcs_info

zstyle ':vcs_info:*' unstagedstr '%F{red}'
zstyle ':vcs_info:*' stagedstr '%F{green}'
zstyle ':vcs_info:*' formats '[%F{cyan}%s%f%u%c%b%%b%F{cyan}%m%f]'
zstyle ':vcs_info:*' actionformats '[%F{cyan}%s%f%u%c%b%%b%F{cyan}%m%f|%a]'
zstyle ':vcs_info:*+set-message:*' hooks set-vcs-symbol set-misc
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*+pre-get-data:*' hooks pre-get-data

+vi-set-vcs-symbol() {
	# return the symbol for the detected vcs
	case "${hook_com[vcs_orig]}" in
		#bzr
		#cdv
		#darcs
		#fossil
		#mtn
		#p4
		#svk
		#tla
		cvs)
			hook_com[vcs]='$'
			;;
		git)
			hook_com[vcs]='±'
			;;
		hg)
			hook_com[vcs]='☿'
			;;
		svn)
			hook_com[vcs]='⚡'
			;;
		# *)
		# 	hook_com[vcs]="${hook_com[vcs]}|"
		# 	;;
	esac
}

+vi-set-misc() {
	if [[ "${hook_com[vcs_orig]}" == git* ]] && whence git &>/dev/null; then
		local ahead behind stashes gitstatus

		ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)
		behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
		if [[ "${ahead}" -gt 0 && "${behind}" -gt 0 ]]; then
			gitstatus='↕'
		elif [[ "${ahead}" -gt 0 && "${behind}" -eq 0 ]]; then
			gitstatus='↑'
		elif [[ "${ahead}" -eq 0 && "${behind}" -gt 0 ]]; then
			gitstatus='↓'
		else
			gitstatus=''
		fi
		stashes=$(git stash list 2>/dev/null | wc -l)
		if [[ "${stashes}" -gt 0 ]]; then
			gitstatus+='•'
		fi

		hook_com[misc]+=${gitstatus}
	fi
}

+vi-pre-get-data() {
	# This variable is used to return the information whether timing should
	# be measured or not. Default to true, change it to false later on if
	# necessary.
	vcs_info_timing=true

	# Only Git and Mercurial support and need caching. Abort if any other
	# VCS is used.
	[[ "$vcs" != git && "$vcs" != hg ]] && return

	# If the shell just started up or we changed directories (or for other
	# custom reasons) we must run vcs_info.
	if [[ -n $FORCE_RUN_VCS_INFO ]]; then
		FORCE_RUN_VCS_INFO=
		return
	fi

	# If we got to this point, running vcs_info was not forced, so now we
	# default to running it only if it was fast the last time.
	# This choice may be overridden later on.
	# (ret=1 means run it, ret=0 means don't)
	[[ "${vcs_info_time}" -lt "${VCS_INFO_THRESHOLD:-0.25}" ]]
	ret=$?

	# If a git/hg command was run then run vcs_info as the status might
	# need to be updated.
	case "$(fc -ln $(($HISTCMD-1)))" in
		git*)
			ret=0
			;;
		hg*)
			ret=0
			;;
	esac

	if [[ ${ret} -ne 0 ]]; then
		vcs_info_timing=false
	fi
}

# }}}

# allow substitution of ${promt_base} and ${vcs_info_msg_0_} in the prompt
setopt promptsubst

precmd_prompt_base() {
	if [[ -z "${VCSH_REPO_NAME}" ]]; then
		# colourise user and hostname
		if [[ "${EUID}" == 0 ]]; then
			# root is red
			user_colour="%B%F{red}"
		else
			# other users are green
			user_colour="%F{green}"
		fi
		if [[ -z "${SSH_CLIENT}" && -z "${SSH_CLIENT2}" ]]; then
			# local shell is blue
			host_colour="%B%F{blue}"
		else
			# remote connection is yellow
			host_colour="%B%F{yellow}"
		fi
		prompt_base="${user_colour}%n%f%b@${host_colour}%m%f%b"
		unset host_colour user_colour
	else
		prompt_base="%F{yellow}${VCSH_REPO_NAME}%f"
	fi
}
add-zsh-hook precmd precmd_prompt_base

# Regular prompt
PS1="\${prompt_base}:%B%F{black}%2~%f%b\${vcs_info_msg_0_}%#"

# Prompt on the right side {{{
function set_RPS1 {
	# current time, colour depends on the exit status of the last command
	RPS1_time="%(?.%B%F{yellow}.%B%F{magenta})[%*]%f%b"
	# display [CMD] when in vicmd mode
	if [[ "$1" = "vicmd" ]]; then
		RPS1_mode="%B%F{yellow}[CMD]%f%b"
	else
		RPS1_mode=""
	fi
	RPS1="${RPS1_mode}${RPS1_time}"
}
set_RPS1

function zle-keymap-select {
	set_RPS1 $KEYMAP
	zle reset-prompt
}
zle -N zle-keymap-select
function zle-line-init {
	# call the terminfo fix from earlier in this file
	if whence terminfo_zle-line-init &>/dev/null; then
		terminfo_zle-line-init
	fi
	set_RPS1 $KEYMAP
	zle reset-prompt
}
zle -N zle-line-init
# redraw the promp when the line finishes to update the time
function zle-line-finish {
	# call the terminfo fix from earlier in this file
	if whence terminfo_zle-line-finish &>/dev/null; then
		terminfo_zle-line-finish
	fi
	zle reset-prompt
}
zle -N zle-line-finish

# catch ^C (SIGINT), reset RPS1, and return the signal
# this is required as pressing ^C in CMD mode displays the wrong prompt in the next line
#function TRAPINT() {
#	set_RPS1
#	return $(( 128 + $1 ))
#}

# }}}

# }}}

# Set the window title {{{
case $TERM in
	*xterm*|rxvt*|(dt|k|E)term|gnome*)
		precmd_title () { print -Pn "\e]0;[%n@%M:%~]\a" }
		preexec_title () { print -Pn "\e]0;[%n@%M:%~] (\$1)\a" }
		add-zsh-hook precmd precmd_title
		add-zsh-hook preexec preexec_title
	;;
    screen|screen-256color)
		precmd_title () {
			print -Pn "\e]83;title \"\$1\"\a"
			print -Pn "\e]0;\$TERM - (%L) [%n@%M:%~]\a"
		}
		preexec_title () {
			print -Pn "\e]83;title \"\$1\"\a"
			print -Pn "\e]0;\$TERM - (%L) [%n@%M:%~] (\$1)\a"
		}
		add-zsh-hook precmd precmd_title
		add-zsh-hook preexec preexec_title
	;;
esac

# }}}

# Crazy Completion Stuff {{{

# Enable user-specific completion scripts (before compinit)
fpath=(~/.zsh_completion.d/ $fpath)

# Enable completion
autoload -Uz compinit
compinit

# formatting {{{

# set formats
zstyle ':completion:*:corrections'  format '%F{red}%d (errors: %e)%f'
zstyle ':completion:*:descriptions' format '%F{red}completing %B%d%b%f'
zstyle ':completion:*:warnings'     format '%F{red}No matches for:%f %d'
zstyle ':completion:*:messages'     format '%d'

# }}}

# general completion settings {{{

setopt completeinword # complete in word, not just at the end

# activate colour-completion
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# enable selecting matches from a menu
zstyle ':completion:*:default' menu select

# match uppercase from lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# provide .. as a completion
zstyle ':completion:*' special-dirs ..

# describe options in full
zstyle ':completion:*:options' description 'yes'
# add generic description
zstyle ':completion:*:options' auto-description '%d'

# separate matches into groups
zstyle ':completion:*:matches' group 'yes'
# assign the name of the tag to each match
zstyle ':completion:*' group-name ''

# }}}

# history completion {{{

# stop before wrapping around in history searches
zstyle ':completion:*:history-words' stop yes

# }}}

# specific completions {{{

# processes {{{
if [[ "$EUID" == 0 ]]; then
	# process completion for root: all processes
	zstyle ':completion:*:processes'       command 'ps -e -o user,pid,cputime,command'
	zstyle ':completion:*:processes-names' command 'ps ax -o command | grep -v "^\[.*\]$" |  uniq'
else
	# process completion of other users: only user processes, unless the
	# current line starts with 'sudo'
	zstyle ':completion:*:processes'       command '[[ ${BUFFER:0:4} == 'sudo' ]] && ps -e -o user,pid,cputime,command || ps -au$USER -o pid,cputime,command'
	zstyle ':completion:*:processes-names' command '[[ ${BUFFER:0:4} == 'sudo' ]] && ps ax -o command | grep -v "^\[.*\]$" | uniq || ps c -u ${USER} -o command | uniq'
fi
# always show a list of processes, even if it is only one
zstyle ':completion:*:*:(kill|killall):*'  force-list always
# do not offer processes already on the command line
zstyle ':completion:*:*:(kill|killall):*'  ignore-line other
# }}}

# {{{
# do not offer parameters already on the command line for these commands
zstyle ':completion:*:(md5|sha*)sum:*' ignore-line other
zstyle ':completion:*:diff:*' ignore-line other
zstyle ':completion:*:colordiff:*' ignore-line other
zstyle ':completion:*:chmod:*' ignore-line other
zstyle ':completion:*:chown:*' ignore-line other
zstyle ':completion:*:rm:*' ignore-line other
zstyle ':completion:*:rmdir:*' ignore-line other
zstyle ':completion:*:shred:*' ignore-line other
zstyle ':completion:*:touch:*' ignore-line other
zstyle ':completion:*:emerge:*' ignore-line other
# }}}

# sudo paths {{{
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin
# }}}

# }}}

# ignoring matches {{{

# show ignored matches if there is nothing else
zstyle '*' single-ignored show

# when completing users, ignore known system accounts
zstyle ':completion:*:*:*:users' ignored-patterns \
adm amanda apache at avahi avahi-autoipd backup bin cacti clamav colord cron \
daemon dbus dhcp distcache dnsmasq dovecot fax ftp games gdm gkrellmd gnats \
haldaemon halt ident irc kdm ldap libuuid list lp mail mailman mailnull man messagebus mpd \
mysql nagios named netdump news nfsnobody nobody nscd ntp openvpn operator \
pcap polkitd portage postfix postgres postmaster privoxy proxy pulse pvm rpc \
rpcuser rpm saned shutdown squid sshd statd svn sync tftp tss usbmux uucp \
www-data wwwrun xfs '_*'

# don't complete backup files as executables
zstyle ':completion:*:complete:-command-::commands' ignored-patterns '*\~'

# ignore completion functions
zstyle ':completion:*:(functions|parameters|association-keys)' ignored-patterns '_*'

# }}}

# correction settings {{{

# Enable correction for commands only
setopt correct
# but ignore everything that starts with _
CORRECT_IGNORE='_*'

# when correcting, provide the original string as a match
zstyle ':completion:*:correct:*' original true
# start menu completion only if it could find no unambiguous initial string
zstyle ':completion:*:correct:*' insert-unambiguous true

# }}}

# }}}

# Sensible Aliases {{{

alias ls='ls --color=auto'
alias ll='ls -lh'
alias grep='grep --color=auto'
alias df='df -h'

# }}}
