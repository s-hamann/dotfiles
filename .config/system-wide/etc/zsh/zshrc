# vim: foldmethod=marker
# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
    # Shell is non-interactive.  Be done now!
    return
fi

autoload -Uz add-zsh-hook

# Key Bindings {{{

# use vi-style key bindings
bindkey -v

# create a zkbd compatible hash, but do not use zkbd itself
# to add other keys to this hash, see: man 5 terminfo
typeset -A key

key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}
if [[ -n ${terminfo[kent]} ]]; then
    key[KeypadEnter]=${terminfo[kent]} # does not work in screen and tmux
else
    key[KeypadEnter]="\eOM" # this is what xterm uses...
fi
key[ShiftTab]=${terminfo[kcbt]}

# bind keys to functions
[[ -n "${key[Home]}"    ]]  && bindkey  "${key[Home]}"    beginning-of-line
[[ -n "${key[End]}"     ]]  && bindkey  "${key[End]}"     end-of-line
[[ -n "${key[Insert]}"  ]]  && bindkey  "${key[Insert]}"  overwrite-mode
[[ -n "${key[Delete]}"  ]]  && bindkey  "${key[Delete]}"  delete-char
[[ -n "${key[Up]}"      ]]  && bindkey  "${key[Up]}"      up-line-or-history
[[ -n "${key[Down]}"    ]]  && bindkey  "${key[Down]}"    down-line-or-history
[[ -n "${key[Left]}"    ]]  && bindkey  "${key[Left]}"    backward-char
[[ -n "${key[Right]}"   ]]  && bindkey  "${key[Right]}"   forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"    history-beginning-search-backward
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}"  history-beginning-search-forward
[[ -n "${key[KeypadEnter]}"   ]]  && bindkey  "${key[KeypadEnter]}"   accept-line
[[ -n "${key[ShiftTab]}"   ]]  && bindkey  "${key[ShiftTab]}"   reverse-menu-complete

unset key

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    #function zle-line-init () {
    function terminfo_zle-line-init () {
        echoti smkx
    }
    #function zle-line-finish () {
    function terminfo_zle-line-finish () {
        echoti rmkx
    }
    #zle -N zle-line-init
    #zle -N zle-line-finish
    # Note: these are called later by the real zle-line-init and zle-line-finish widgets
fi

# Ctrl+arrow keys, these do not seem to have a terminfo entry
bindkey -M viins "\e[1;5D" backward-word
bindkey -M viins "\e[1;5C" forward-word
bindkey -M vicmd "\e[1;5D" backward-word
bindkey -M vicmd "\e[1;5C" forward-word

# make backward-word, forward-word and ^W not stop at the following characters
# default: WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>'
export WORDCHARS=${WORDCHARS:s@/@} # remove /

# reduce lag when changing line editing modes
export KEYTIMEOUT=1
# fix some keys that do not work after returning from command mode
bindkey '^?' backward-delete-char
bindkey '^H' backward-delete-char
bindkey '^W' backward-kill-word
bindkey '^U' backward-kill-line
bindkey '^K' kill-line

insert-last-typed-word() { zle insert-last-word -- 0 -1 };
zle -N insert-last-typed-word;

# use Ctrl+R for backward search in history
bindkey '^R' history-incremental-pattern-search-backward
# make . work in history search
bindkey -M isearch '.' self-insert
# use Ctrl+Y to insert the last string deleted by ^U or whatever
bindkey -M viins '^Y' yank
# use Alt+. to insert the last parameter from the previous command
bindkey -M viins '^[.' insert-last-word
# use Ctrl+Z to insert the last parameter from the current command
bindkey -M viins '^Z' insert-last-typed-word
# use ga in vicmd mode to get information about the character under the cursor
bindkey -M vicmd ga what-cursor-position
# make # in vicmd toggle comment, but not accept the line
bindkey -M vicmd '#' vi-pound-insert
# make ESC exit mini-buffers
bindkey -M command '^[' send-break
bindkey -M isearch '^[' send-break
# use Y to yank to the end of a line, instead of the whole line
bindkey -M vicmd 'Y' vi-yank-eol
# use K in vicmd to open the man-page
bindkey -M vicmd 'K' run-help
# make H/L go to the start/end of the line in vicmd
bindkey -M vicmd 'H' beginning-of-line
bindkey -M vicmd 'L' end-of-line

# enable the powerful command line editor
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey -M vicmd 'v' edit-command-line

if zmodload zsh/regex &>/dev/null; then
    # This was written entirely by Mikael Magnusson
    # Basically type '...' to get '../..' with successive .'s adding /..
    function rationalise-dot {
        # keep variables that are generated by =~ local
        local MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
        if [[ $LBUFFER =~ '(^|/| | |'$'\n''|\||;|&)\.\.$' ]]; then
            LBUFFER+=/
            zle self-insert
            zle self-insert
        else
            zle self-insert
        fi
    }
    zle -N rationalise-dot
    # Note: do not bind this in other modes!
    bindkey -M viins . rationalise-dot
fi

if zmodload zsh/regex &>/dev/null; then
    prepend-sudo() {
        # keep variables that are generated by =~ local
        local MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
        # prepend sudo if the line does not start with sudo already
        if [[ ! $LBUFFER =~ '^\s*sudo ' ]]; then
            LBUFFER="sudo $LBUFFER"
        fi
    }
    # Note: The widget is named differently from the function because otherwise
    # zsh-syntax-highlighting would not update afterwards.
    zle -N zle-prepend-sudo prepend-sudo
    bindkey -M viins "^[s" zle-prepend-sudo
    bindkey -M vicmd "^[s" zle-prepend-sudo
fi

# }}}

# Colour settings {{{

# Set $TERM to support colours
if [[ -n "${COLORTERM}" || -n "${VTE_VERSION}" ]]; then
    case "$TERM" in
        'xterm') TERM='xterm-256color' ;;
        'screen') TERM='screen-256color' ;;
        'tmux') TERM='tmux-256color' ;;
    esac
    export TERM
fi

# set LS_COLORS, which is used by ls and some others to colourise file names
if type dircolors > /dev/null ; then
    if [[ -f "~/.dir_colors.$TERM" ]]; then
        eval $(dircolors -b -- "~/.dir_colors.$TERM")
    elif [[ -f "${PREFIX}/etc/DIR_COLORS.$TERM" ]] ; then
        eval $(dircolors -b -- "${PREFIX}/etc/DIR_COLORS.$TERM")
    elif [[ -f "~/.dir_colors" ]]; then
        eval $(dircolors -b -- "~/.dir_colors")
    elif [[ -f "${PREFIX}/etc/DIR_COLORS" ]] ; then
        eval $(dircolors -b -- "${PREFIX}/etc/DIR_COLORS")
    fi
fi

# support colours in less
export LESS_TERMCAP_mb=$'\E[01;31m' # begin blink
export LESS_TERMCAP_md=$'\E[01;34m' # begin bold
export LESS_TERMCAP_me=$'\E[0m' # end mode
export LESS_TERMCAP_so=$'\E[01;33m' # begin stand-out mode
export LESS_TERMCAP_se=$'\E[0m' # end stand-out mode
export LESS_TERMCAP_us=$'\E[04;32m' # begin underline
export LESS_TERMCAP_ue=$'\E[0m' # end underline

# coloured GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# nice colours in grep
export GREP_COLORS='sl=38;5;230:ms=1;4;38;5;221:mc=4;38;5;221:fn=38;5;165:ln=38;5;46:se=38;5;241'

# }}}

# History settings {{{
HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=5000
setopt appendhistory # append to existing history rather than writing a new one
setopt hist_ignore_dups # ignore consecutive duplicates
setopt hist_ignore_space # ignore commands with a leading space
setopt hist_reduce_blanks # remove superfluous blanks from history
setopt hist_find_no_dups # ignore all duplicates when searching the history
setopt no_bang_hist # disable access to the history with !

if zmodload zsh/regex &>/dev/null; then
    # the following function allows to exclude boring commands from the history
    zshaddhistory_ignore() {
        # $1 is the command line
        # return value means
        # 0 - add to history
        # 1 - do not add to history
        # 2 - add to history but do not store in history file
        # uses $HISTIGNORE, which should be an array of regexes

        # keep variables that are generated by =~ local
        local regex MATCH MBEGIN MEND match mbegin mend BASH_REMATCH
        # check if this is configured at all
        [[ -z "${HISTIGNORE}" ]] && return 0
        # try each regex in $HISTIGNORE until the first match
        for regex in ${HISTIGNORE}; do
            [[ "${1%%$'\n'}" =~ "$regex" ]] && return 2
        done
        # nothing matched
        return 0
    }

    add-zsh-hook zshaddhistory zshaddhistory_ignore

    HISTIGNORE=()
    # no command with only one or two characters is important enough for the history
    HISTIGNORE+=('^..?$')
    HISTIGNORE+=('^l(s|l) ')
    HISTIGNORE+=('^pwd$')
    HISTIGNORE+=('^git (s|status|log|graph)$')
    HISTIGNORE+=('^kill ')
    #HISTIGNORE+=('^(exit|logout)$')
    #HISTIGNORE+=('^clear$')
fi

# }}}

# Directory navigation {{{
setopt auto_cd
setopt auto_pushd
setopt pushd_ignore_dups
# }}}

# Various settings {{{

# allow comments in the interactive shell
setopt interactive_comments

# make > not overwrite files (use >! or >| instead)
# also, >> does not create new files (again, >>! or >>|)
setopt no_clobber

# disable weird output freezing with ctrl+s/ctrl+q
setopt noflowcontrol

# disable =command to full path expansion
setopt noequals

# }}}

# Crazy Prompt Settings {{{

# enable colours
autoload -Uz colors
colors

# set up vcs_info {{{
autoload -Uz vcs_info

# Default to running vcs_info. If possible we prevent running it later for
# speed reasons. If set to a non empty value vcs_info is run.
FORCE_RUN_VCS_INFO=1

zmodload zsh/datetime

precmd_vcs_info() {
    # Run vcs_info and measure how long it takes.
    local vcs_info_start vcs_info_finish
    vcs_info_start=$EPOCHREALTIME
    vcs_info
    vcs_info_finish=$EPOCHREALTIME
    # Update vcs_info_time with the measured time if this run was not
    # aborted early by pre-get-data.
    ${vcs_info_timing} && vcs_info_time=$(( $vcs_info_finish - $vcs_info_start ))
    unset vcs_info_timing
}
add-zsh-hook precmd precmd_vcs_info

# Must run vcs_info when changing directories.
chpwd_vcs_info() {
    FORCE_RUN_VCS_INFO=1
}
add-zsh-hook chpwd chpwd_vcs_info

zstyle ':vcs_info:*' unstagedstr '%F{1}'
zstyle ':vcs_info:*' stagedstr '%F{2}'
zstyle ':vcs_info:*' formats '[%F{6}%s%f%u%c%b%%b%F{6}%m%f]'
zstyle ':vcs_info:*' actionformats '[%F{6}%s%f%u%c%b%%b%F{6}%m%f|%a]'
zstyle ':vcs_info:*+set-message:*' hooks set-vcs-symbol set-misc
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*+pre-get-data:*' hooks pre-get-data

+vi-set-vcs-symbol() {
    # return the symbol for the detected vcs
    case "${hook_com[vcs_orig]}" in
        #bzr
        #cdv
        #darcs
        #fossil
        #mtn
        #p4
        #svk
        #tla
        cvs)
            hook_com[vcs]='$'
            ;;
        git)
            hook_com[vcs]='±'
            ;;
        hg)
            hook_com[vcs]='☿'
            ;;
        svn)
            hook_com[vcs]='⚡'
            ;;
        # *)
        #   hook_com[vcs]="${hook_com[vcs]}|"
        #   ;;
    esac
}

+vi-set-misc() {
    if [[ "${hook_com[vcs_orig]}" == git* ]] && whence git &>/dev/null; then
        local ahead behind stashes gitstatus

        ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)
        behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
        if [[ "${ahead}" -gt 0 && "${behind}" -gt 0 ]]; then
            gitstatus='↕'
        elif [[ "${ahead}" -gt 0 && "${behind}" -eq 0 ]]; then
            gitstatus='↑'
        elif [[ "${ahead}" -eq 0 && "${behind}" -gt 0 ]]; then
            gitstatus='↓'
        else
            gitstatus=''
        fi
        stashes=$(git stash list 2>/dev/null | wc -l)
        if [[ "${stashes}" -gt 0 ]]; then
            gitstatus+='•'
        fi

        hook_com[misc]+=${gitstatus}
    fi
}

+vi-pre-get-data() {
    # This variable is used to return the information whether timing should
    # be measured or not. Default to true, change it to false later on if
    # necessary.
    vcs_info_timing=true

    # Only Git and Mercurial support and need caching. Abort if any other
    # VCS is used.
    [[ "$vcs" != git && "$vcs" != hg ]] && return

    # If the shell just started up or we changed directories (or for other
    # custom reasons) we must run vcs_info.
    if [[ -n $FORCE_RUN_VCS_INFO ]]; then
        FORCE_RUN_VCS_INFO=
        return
    fi

    # If we got to this point, running vcs_info was not forced, so now we
    # default to running it only if it was fast the last time.
    # This choice may be overridden later on.
    # (ret=1 means run it, ret=0 means don't)
    [[ "${vcs_info_time}" -lt "${VCS_INFO_THRESHOLD:-0.25}" ]]
    ret=$?

    # If a git/hg command was run then run vcs_info as the status might
    # need to be updated.
    case "$(fc -ln $(($HISTCMD-1)))" in
        git*)
            ret=0
            ;;
        hg*)
            ret=0
            ;;
    esac

    if [[ ${ret} -ne 0 ]]; then
        vcs_info_timing=false
    fi
}

# }}}

# Prompt on the left side {{{

# It works like this: The prompt consists of the varying base, the current path
# and, possibly, information about a VCS repository.  The base prompt allows for
# the following modifications:
# * $zsh_prompt_user - formatting of the user name
# * $zsh_prompt_host - formatting of the host name
# * $zsh_prompt_base - an associative array. If the key exists as a non-empty
#    environment variable, the value is used as the prompt base. If multiple
#    keys match, only one of them is honoured. Which one, however, is undefined.

# set the default formatting of the user name in the prompt
if [[ "${EUID}" == 0 ]]; then
    # root is red
    zsh_prompt_user="%B%F{9}"
else
    # other users are green
    zsh_prompt_user="%F{2}"
fi

# set the default formatting of the host name in the prompt
if [[ -z "${SSH_CONNECTION}" ]]; then
    # local shell is blue
    zsh_prompt_host="%B%F{12}"
else
    # remote connection is yellow
    zsh_prompt_host="%B%F{11}"
fi

# allow substitution of variables in the prompt
setopt prompt_subst

typeset -A zsh_prompt_base
# default base prompt: user@hostname
zsh_prompt_base[ZSH_DEFAULT_PROMPT]='${zsh_prompt_user}%n%f%k%b%u%s@${zsh_prompt_host}%m%f%k%b%u%s'
zsh_prompt_base[VIRTUAL_ENV]='${zsh_prompt_user}$(basename -- "${VIRTUAL_ENV}")%f%k%b%u%s@${zsh_prompt_host}%m%f%k%b%u%s'

precmd_prompt() {
    # set the default prompt base
    local prompt_base="${zsh_prompt_base[ZSH_DEFAULT_PROMPT]}"
    # check all array keys in $zsh_prompt_base
    local var
    for var in "${(@k)zsh_prompt_base}"; do
        # check if the key is an environment variable
        if [[ -n "${(P)var}" ]]; then
            # set the prompt base from zsh_prompt_base
            prompt_base="${zsh_prompt_base[$var]}"
            break
        fi
    done
    # put the actual prompt together
    PS1="${prompt_base}:%F{8}%2~%f%b\${vcs_info_msg_0_}%#"
}
add-zsh-hook precmd precmd_prompt

# }}}

# Prompt on the right side {{{
function set_RPS1 {
    local RPS1_time RPS1_mode
    # current time, colour depends on the exit status of the last command
    RPS1_time="%(?.%B%F{11}.%B%F{13})[%*]%f%b"
    # display [CMD] when in vicmd mode
    if [[ "$1" = "vicmd" ]]; then
        RPS1_mode="%B%F{11}[CMD]%f%b"
    else
        RPS1_mode=""
    fi
    RPS1="${RPS1_mode}${RPS1_time}"
}
set_RPS1

function zle-keymap-select {
    set_RPS1 $KEYMAP
    zle reset-prompt
}
zle -N zle-keymap-select
function zle-line-init {
    # call the terminfo fix from earlier in this file
    if whence terminfo_zle-line-init &>/dev/null; then
        terminfo_zle-line-init
    fi
    set_RPS1 $KEYMAP
    zle reset-prompt
}
zle -N zle-line-init
# redraw the promp when the line finishes to update the time
function zle-line-finish {
    # call the terminfo fix from earlier in this file
    if whence terminfo_zle-line-finish &>/dev/null; then
        terminfo_zle-line-finish
    fi
    zle reset-prompt
}
zle -N zle-line-finish

# catch ^C (SIGINT), reset RPS1, and return the signal
# this is required as pressing ^C in CMD mode displays the wrong prompt in the next line
#function TRAPINT() {
#   set_RPS1
#   return $(( 128 + $1 ))
#}

# }}}

# mark partial lines with a nice unicode symbol instead of the default %
PROMPT_EOL_MARK="%F{red}⏎"

# }}}

# Set the window title {{{
case $TERM in
    *xterm*|rxvt*|(dt|k|E)term|gnome*)
        precmd_title () { print -Pn "\e]0;[%n@%m:%~]\a" }
        preexec_title () { print -Pn "\e]0;[%n@%m:%~] (\$1)\a" }
        add-zsh-hook precmd precmd_title
        add-zsh-hook preexec preexec_title
    ;;
    screen|screen-256color|tmux|tmux-256color)
        precmd_title () {
            print -Pn "\e]83;title \"\$1\"\a"
            print -Pn "\e]0;[%n@%m:%~]\a"
        }
        preexec_title () {
            print -Pn "\e]83;title \"\$1\"\a"
            print -Pn "\e]0;[%n@%m:%~] (\$1)\a"
        }
        add-zsh-hook precmd precmd_title
        add-zsh-hook preexec preexec_title
    ;;
esac

# }}}

# Crazy Completion Stuff {{{

# Enable user-specific completion scripts (before compinit)
fpath=(~/.zsh_completion.d/ $fpath)

# Enable completion
autoload -Uz compinit
compinit

# formatting {{{

# set formats
zstyle ':completion:*:corrections'  format '%F{1}%d (errors: %e)%f'
zstyle ':completion:*:descriptions' format '%F{1}completing %B%d%b%f'
zstyle ':completion:*:warnings'     format '%F{1}No matches for:%f %d'
zstyle ':completion:*:messages'     format '%d'

# }}}

# general completion settings {{{

setopt completeinword # complete in word, not just at the end

setopt numeric_glob_sort # sort numeric filename matches numerically rather than lexicographically

# activate colour-completion
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# enable selecting matches from a menu
zstyle ':completion:*:default' menu select

# match uppercase from lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# provide .. as a completion
zstyle ':completion:*' special-dirs ..

# describe options in full
zstyle ':completion:*:options' description 'yes'
# add generic description
zstyle ':completion:*:options' auto-description '%d'

# separate matches into groups
zstyle ':completion:*:matches' group 'yes'
# assign the name of the tag to each match
zstyle ':completion:*' group-name ''

# }}}

# history completion {{{

# stop before wrapping around in history searches
zstyle ':completion:*:history-words' stop yes

# }}}

# specific completions {{{

# processes {{{
if [[ "$EUID" == 0 ]]; then
    # process completion for root: all processes
    zstyle ':completion:*:processes'       command 'ps -e -o user,pid,cputime,command'
    zstyle ':completion:*:processes-names' command 'ps ax -o command | grep -v "^\[.*\]$" |  uniq'
else
    # process completion of other users: only user processes, unless the
    # current line starts with 'sudo'
    zstyle ':completion:*:processes'       command '[[ ${BUFFER:0:4} == 'sudo' ]] && ps -e -o user,pid,cputime,command || ps -au$USER -o pid,cputime,command'
    zstyle ':completion:*:processes-names' command '[[ ${BUFFER:0:4} == 'sudo' ]] && ps ax -o command | grep -v "^\[.*\]$" | uniq || ps c -u ${USER} -o command | uniq'
fi
# always show a list of processes, even if it is only one
zstyle ':completion:*:*:(kill|killall):*'  force-list always
# do not offer processes already on the command line
zstyle ':completion:*:*:(kill|killall):*'  ignore-line other
# }}}

# {{{
# do not offer parameters already on the command line for these commands
zstyle ':completion:*:(md5|sha*)sum:*' ignore-line other
zstyle ':completion:*:diff:*' ignore-line other
zstyle ':completion:*:colordiff:*' ignore-line other
zstyle ':completion:*:chmod:*' ignore-line other
zstyle ':completion:*:chown:*' ignore-line other
zstyle ':completion:*:rm:*' ignore-line other
zstyle ':completion:*:rmdir:*' ignore-line other
zstyle ':completion:*:shred:*' ignore-line other
zstyle ':completion:*:touch:*' ignore-line other
zstyle ':completion:*:emerge:*' ignore-line other
# }}}

# sudo paths {{{
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin
# }}}

# }}}

# ignoring matches {{{

# show ignored matches if there is nothing else
zstyle '*' single-ignored show

# when completing users, ignore known system accounts
zstyle ':completion:*:*:*:users' ignored-patterns \
adm amanda apache at avahi avahi-autoipd backup bin cacti clamav colord cron \
daemon dbus dhcp distcache dnsmasq dovecot fax ftp games gdm gkrellmd gnats \
haldaemon halt ident irc kdm ldap libuuid list lp mail mailman mailnull man messagebus mpd \
mysql nagios named netdump news nfsnobody nobody nscd ntp openvpn operator \
pcap polkitd portage postfix postgres postmaster privoxy proxy pulse pvm rpc \
rpcuser rpm saned shutdown squid sshd statd svn sync tftp tss usbmux uucp \
www-data wwwrun xfs '_*'

# don't complete backup files as executables
zstyle ':completion:*:complete:-command-::commands' ignored-patterns '*\~'

# ignore completion functions
zstyle ':completion:*:(functions|parameters|association-keys)' ignored-patterns '_*'

# }}}

# correction settings {{{

# Enable correction for commands only
setopt correct
# but ignore everything that starts with _
CORRECT_IGNORE='_*'

# when correcting, provide the original string as a match
zstyle ':completion:*:correct:*' original true
# start menu completion only if it could find no unambiguous initial string
zstyle ':completion:*:correct:*' insert-unambiguous true

# }}}

# }}}

# Sensible Aliases {{{

function is_busybox() {
    # Usage: is_busybox cmd
    # tries to determine if cmd is a busybox implementation
    [[ "${$(whence -pS "$1")##*/}" == 'busybox' ]]
}

if whence lsd >/dev/null; then
    alias ls='lsd'
    alias ll='lsd -l'
else
    alias ls='ls --color=auto'
    alias ll='ls -lh'
fi
is_busybox grep || alias grep='grep --color=auto'
is_busybox diff || alias diff='diff --color=auto'
alias df='df -h'
whence ip >/dev/null && ! is_busybox ip && alias ip='ip -c'

# }}}
